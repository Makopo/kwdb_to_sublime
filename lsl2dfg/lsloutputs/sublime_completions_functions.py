#!/usr/bin/env python

# sublime.py - This is a LSL2dfg.py output module that outputs all the
# functions, events and constants in the database with their signatures,
# types and values.

import sys
import codecs

def output(document, defaultdescs, databaseversion, infilename, outfilename, lang, tag):

  def get_signature(element):
    sign = "{{ \"trigger\": \"{name}\\t({type}) function\", \"contents\": \"{name}("\
      .format(name=element["name"], type=element["type"] if "type" in element else "void")
    first = True
    if "params" in element:
      cnt = 1;
      for param in element["params"]:
        if first:
          first = False
        else:
          sign = sign + ", "
        sign = sign + "${{{idx}:{type} {name}}}".format(idx=cnt, name=param["name"], type=param["type"])
        cnt += 1;
    sign = sign + ")\" }"
    return sign

  # starting main sequence here

  functions = []
  for element in document:
    if 'status' not in element or element['status'] == 'normal':
      if element["cat"] == "function":
        functions.append(element)
  functions.sort(key = lambda x: x["name"])

  if infilename is not None:
    inf = open(infilename, "r")
  else:
    inf = sys.stdin

  try:
    inputlines = inf.readlines()

  finally:
    if infilename is not None:
      inf.close()

  if outfilename is not None:
    outf = codecs.open(outfilename, "w", "utf-8")
  else:
    outf = sys.stdout

  try:

    for line in inputlines:
      if not line.startswith("<<< LINES >>>"):
        outf.write(line)
      else:
        outf.write("// Generated by LSL2 Derived Files Generator. Database version: {0}\n//\n"
          .format(databaseversion))
        outf.write("\t\t")
        outf.write(",\n\t\t".join([get_signature(element) for element in functions]))
        outf.write("\n")

  finally:
    if outfilename is not None:
      outf.close()

pass